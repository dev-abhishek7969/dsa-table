<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <title>DSA Problem Table</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      background-color: #1e1e1e;
      color: #fff;
      margin: 0;
      padding: 20px;
    }

    table {
      width: 100%;
      border-collapse: collapse;
      margin-bottom: 60px;
    }

    th,
    td {
      border: 1px solid #444;
      padding: 10px;
      text-align: left;
    }

    .category-row {
      background-color: #333;
      font-weight: bold;
      cursor: pointer;
    }

    .code-btn {
      background-color: #007bff;
      color: #fff;
      border: none;
      padding: 6px 12px;
      cursor: pointer;
    }

    .code-btn:hover {
      background-color: #0056b3;
    }

    #codeModal {
      display: none;
      position: fixed;
      z-index: 9999;
      left: 0;
      top: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(0, 0, 0, 0.6);
      align-items: center;
      justify-content: center;
    }

    #codeModalContent {
      background-color: #ffffff;
      color: #000000;
      padding: 20px;
      border-radius: 8px;
      max-width: 800px;
      width: 90%;
      max-height: 90%;
      overflow: auto;
    }

    pre {
      white-space: pre-wrap;
      color: #000000;
      font-family: Consolas, monospace;
    }

    .close-btn {
      float: right;
      font-size: 20px;
      cursor: pointer;
      color: #666;
    }

    .close-btn:hover {
      color: #000;
    }

    .toggle-icon {
      float: right;
      font-size: 16px;
      color: #ccc;
    }

    .hidden {
      display: none;
    }

    .category-row:hover {
      background-color: #444;
    }
  </style>
</head>

<body>

  <h1>DSA Problem Table</h1>
  <table>
    <tbody id="problem-table"></tbody>
  </table>

  <div id="codeModal">
    <div id="codeModalContent">
      <span class="close-btn" onclick="closeModal()">&times;</span>
      <pre id="codeText"></pre>
    </div>
  </div>

  <script>
    function generateDummyProblems(categoryName, startIndex) {
      const problems = [];
      for (let i = 1; i <= 5 - startIndex; i++) {
        const problemName = `${categoryName} Problem ${startIndex + i}`;
        const code = `// Code for ${problemName}
public class Solution {
  public void solve() {
    System.out.println("Solving ${problemName}");
  }
}`;
        problems.push({ name: problemName, code });
      }
      return problems;
    }

    const categories = [
      { name: "Linked List", problems: [] },
      { name: "Binary Search", problems: [] },
      { name: "Stack and Queue", problems: [] },
      { name: "Two Pointer", problems: [] },
      { name: "Sliding Window", problems: [] },
      { name: "Longest-Reverse", problems: [] },
      { name: "Memoization", problems: [] },
      { name: "HashMap DS", problems: [] },
      { name: "Brain Teasers", problems: [] }
    ];

    // Linked List problems
    const linkedListCategory = categories.find(cat => cat.name === "Linked List");
    linkedListCategory.problems.push(
      {
        name: "Merge two linked list",
        code: `public static ListNode mergeTwoLists(ListNode l1, ListNode l2) {		
		ListNode returnNode = new ListNode(Integer.MIN_VALUE);		
		ListNode headNode = returnNode;		
		while(l1 != null && l2 != null){
			if(l1.val <= l2.val) {
				returnNode.next= l1;
				l1=l1.next;
			}
			else {
				returnNode.next=l2;
				l2=l2.next;
			}			
			returnNode = returnNode.next;	
		}
		if(l1 == null) {
			returnNode.next=l2;
		}
		else if(l2 == null) {
			returnNode.next=l1;
		}
		return headNode;
	   }`
      },

      {
        name: "Middle node of linked list",
        code: `public static ListNode middleNode(ListNode head) {
		ListNode slowPtr = head;
		ListNode fastPtr = head;

		while (null != fastPtr && null != fastPtr.next) {
			slowPtr = slowPtr.next;
			fastPtr = fastPtr.next.next;
		}
		return slowPtr;
	  }`
      },

      {
        name: "Is given linked list circular",
        code: `public boolean hasCycle(ListNode head) {
		ListNode slowPtr = head;
		ListNode fastPtr = head;

		while (null != fastPtr && null != fastPtr.next) {
			slowPtr = slowPtr.next;
			fastPtr = fastPtr.next.next;
			
			if (slowPtr == fastPtr) {
				return true;
			}
		}

		return false;

	}`
      },


      {
        name: "Starting point of cycle in linked list",
        code: `public ListNode detectCycle(ListNode head) {
  ListNode slow = head, fast = head;
  while (fast != null && fast.next != null) {
    fast = fast.next.next;
    slow = slow.next;
    if (slow == fast) {
      while (head != slow) {
        head = head.next;
        slow = slow.next;
      }
      return slow;
    }
  }
  return null;
}`
      },
      {
        name: "Intersection of Two Linked List",
        code: `public ListNode getIntersectionNode(ListNode headA, ListNode headB) {
  int a = getListLength(headA);
  int b = getListLength(headB);

  while (a > b) {
    headA = headA.next;
    a--;
  }
  while (b > a) {
    headB = headB.next;
    b--;
  }
  while (headA != headB) {
    headA = headA.next;
    headB = headB.next;
  }

  return headB;
}

private int getListLength(ListNode head) {
  int len = 0;
  while (head != null) {
    len++;
    head = head.next;
  }
  return len;
}`
      }
    );
    //linkedListCategory.problems.push(...generateDummyProblems("Linked List", 2));

    // Binary Search problems
    const binarySearchCategory = categories.find(cat => cat.name === "Binary Search");
    binarySearchCategory.problems = [
      {
        name: "Binary Search",
        code: `public int search(int[] nums, int target) {
  int start = 0;
  int end = nums.length - 1;

  while (start <= end) {
    int mid = start + (end - start) / 2;
    if (target < nums[mid]) {
      end = mid - 1;
    } else if (target > nums[mid]) {
      start = mid + 1;
    } else {
      return mid;
    }
  }
  return -1;
}`
      },

      {
        name: "Find Minimum in Rotated Sorted Array",
        code: `/**
	 * Input: nums = [3,4,5,1,2] Output: 1
	 */
	public int findMin(int[] nums) {

		int left = 0;
		int right = nums.length - 1;

		while (left < right) {
			int mid = left + (right - left) / 2;

			if (nums[mid] > nums[right]) {
				left = mid + 1;
			} else {
				right = mid;
			}
		}
		return nums[left];
	}`
      },

      {
        name: "Ceiling",
        code: `//The least integer number greater than or equal to the given number
	static int ceiling(int[] arr, int target) {
		int start = 0;
		int end = arr.length - 1;

		if (target > arr[end]) {
			return -1;
		}

		while (start <= end) {
			int mid = start + (end - start) / 2;

			if (target == arr[mid]) {
				return mid;
			} else if (target > arr[mid]) {
				start = mid + 1;
			} else {
				end = mid - 1;
			}
		}
		return start;
	}`
      },

      {
        name: "Floor",
        code: `static int floor(int[] arr, int target) {
		int start = 0;
		int end = arr.length - 1;

		if (target > arr[end]) {
			return -1;
		}

		while (start <= end) {
			int mid = start + (end - start) / 2;

			if (target == arr[mid]) {
				return mid;
			} else if (target > arr[mid]) {
				start = mid + 1;
			} else {
				end = mid - 1;
			}
		}
		return end;
	}`
      },

      {
        name: "Order Agnostic Binary Search",
        code: `public static int OrderAgnosticBs(int arr[], int target) {
		int start = 0;
		int end = arr.length - 1;
		boolean isAsc = false;

		// find whether the array is sorted in asc or descending
		if (arr[start] <= arr[end]) {
			isAsc = true;
		}
		while (start <= end) {
			int mid = start + (end - start) / 2;
			if (target == arr[mid]) {
				return mid;
			}
			if (isAsc) {
				if (target < arr[mid]) {
					end = mid - 1;
				} else {
					start = mid + 1;
				}
			} else {
				if (target > arr[mid]) {
					end = mid - 1;
				} else {
					start = mid + 1;
				}
			}
		}
		return -1;
	}`
      },

      {
        name: "Find First and Last Position of Element in Sorted Array",
        code: `/**
	 * Input: nums = [5,7,7,8,8,10], target = 8 Output: [3,4]
	 * 
	 */
	public static int[] searchRange(int[] nums, int target) {

		int[] ans = { -1, -1 };
		int start = search(nums, target, true);
		int end = search(nums, target, false);
		ans[0] = start;
		ans[1] = end;
		return ans;
	}

	private static int search(int[] nums, int target, boolean findStart) {
		int start = 0;
		int end = nums.length - 1;
		int ans = -1;

		while (start <= end) {
			int mid = start + (end - start) / 2;

			if (target < nums[mid]) {
				end = mid - 1;
			} else if (target > nums[mid]) {
				start = mid + 1;
			} else {
				ans = mid;
				if (findStart) {
					end = mid - 1;
				} else {
					start = mid + 1;
				}
			}
		}
		return ans;
	}`
      },

      {
        name: "Find Smallest Letter Greater Than Target",
        code: `/**
	 * Input: letters = ["c","f","j"], target = "c" Output: "f"
	 */

	public static char nextGreatestLetter(char[] letters, char target) {
		int start = 0;
		int end = letters.length-1;

		while (start <= end) {
			int mid = start + (end - start) / 2;

			if (target > letters[mid]) {
				start = mid + 1;
			} else {
				end = mid - 1;
			}
		}
		return letters[start % (letters.length)];
	}`
      },


      //...generateDummyProblems("Binary Search", 1)
    ];

    // Stack and Queue problems
    const stackQueueCategory = categories.find(cat => cat.name === "Stack and Queue");
    stackQueueCategory.problems = [
      {
        name: "Min Stack",
        code: `class MinStack {
  Stack<Integer> stack;
  Stack<Integer> minStack;

  public MinStack() {
    stack = new Stack<>();
    minStack = new Stack<>();
  }

  public void push(int val) {
    stack.push(val);
    if (minStack.isEmpty() || val <= minStack.peek()) {
      minStack.push(val);
    }
  }

  public void pop() {
    int popVal = stack.pop();
    if (popVal == minStack.peek()) {
      minStack.pop();
    }
  }

  public int top() {
    return stack.peek();
  }

  public int getMin() {
    return minStack.peek();
  }
}`,
      },
      {
        name: "Implement Stack using Queues",
        code: `class MyStack {

  private Queue<Integer> queue;

  public MyStack() {
    queue = new LinkedList<>();
  }

  public void push(int x) {
    queue.add(x);
    for (int i = 1; i < queue.size(); i++) {
      queue.add(queue.remove());
    }
  }

  public int pop() {
    return queue.remove();
  }

  public int top() {
    return queue.peek();
  }

  public boolean empty() {
    return queue.isEmpty();
  }
}`,
      },

      {
        name: "Implement Queue using Stack",
        code: `public class QueueUsingStack {

	private final Stack<Integer> input;
	private final Stack<Integer> output;

	public QueueUsingStack() {
		this.input = new Stack<>();
		this.output = new Stack<>();
	}

	public void push(int x) {
		input.push(x);
	}

	public int pop() {
		peek();
		return output.pop();
	}

	public int peek() {
		if (output.isEmpty()) {
			while (!input.isEmpty()) {
				output.push(input.pop());
			}
		}
		return output.peek();
	}

	public boolean empty() {
		return input.isEmpty() && output.isEmpty();
	}
}
`
      },
      //...generateDummyProblems("Stack and Queue", 2)
    ];


    // Two Pointer problems
    const twoPointerCategory = categories.find(cat => cat.name === "Two Pointer");
    twoPointerCategory.problems = [

      {
        name: "Is palindrome",
        code: `/**
 * Input: s = "A man, a plan, a canal: Panama" 
 * Output: true 
 * Explanation: "amanaplanacanalpanama" is a palindrome.
 * 
 * @param s
 * @return
 */
public static boolean isPalindrome(String s) {
  if (s.isEmpty())
    return true;

  int start = 0;
  int end = s.length() - 1;

  while (start < end) {
    char first = s.charAt(start);
    char last = s.charAt(end);

    if (!Character.isLetterOrDigit(first)) {
      start++;
    } else if (!Character.isLetterOrDigit(last)) {
      end--;
    } else {
      if (Character.toLowerCase(first) != Character.toLowerCase(last)) {
        return false;
      }
      start++;
      end--;
    }
  }
  return true;
}`
      },

      {
        name: "Reverse only letters",
        code: `/**
	 * input - "ab-cd*edf"
	 * output - "fd-ed*cba"
	 * @param s
	 * @return
	 */
	public static String reverseOnlyLetters(String s) {
		char[] ch = s.toCharArray();

		int left = 0;
		int right = ch.length - 1;

		while (left < right) {
			if (!Character.isLetter(ch[left])) {
				left++;
			} else if (!Character.isLetter(ch[right])) {
				right--;
			} else {
				char temp = ch[left];
				ch[left] = ch[right];
				ch[right] = temp;
				left++;
				right--;
			}
		}
		return new String(ch);
	}`
      },

      {
        name: "Three sum",
        code: `/**
	 * Input: nums = [-1,0,1,2,-1,-4] Output: [[-1,-1,2],[-1,0,1]] 
	 */
  public static List<List<Integer>> threeSum(int[] arr) {
		if (arr == null || arr.length < 3)
			return new ArrayList<>();
		Arrays.sort(arr);

		Set<List<Integer>> result = new HashSet<>();
		for (int i = 0; i < arr.length - 2; i++) {
			int left = 0;
			int right = arr.length - 1;

			while (left < right) {
				int sum = arr[i] + arr[left] + arr[right];
				
				if (sum == 0) {
					result.add(Arrays.asList(arr[i], arr[left], arr[right]));
					left++;
					right--;
				} else if (sum < 0) {
					left++;
				} else {
					right--;
				}
			}
		}
		return new ArrayList<>(result);
	}
	`
      },

      {
        name: "Two sum sorted array",
        code: `public static int[] twoSum(int[] nums, int target) {
		int first = 0;
		int last = nums.length-1;
		while(first < last) {
			int sum = nums[first]+nums[last];			
			if(sum == target) {
				break;
			}
			else if(sum > target) {
				last --;
			}
			else {
				first++;
			}
		}
		return new int[] {first,last} ;
	}`
      },

      {
        name: "Reverse Words In A String III ",
        code: `//welcome to --> emoclew ot

	public static String reverseWords(String s) {
		String param[] = s.split(" ");
		StringBuffer result = new StringBuffer();

		for (String ss : param) {
			result.append(reverse(ss) + " ");
		}
		return result.toString().trim();
	}

	private static String reverse(String ss) {
		int left = 0;
		int right = ss.length() - 1;

		char[] ch = ss.toCharArray();
		while (left < right) {
			char temp = ch[left];
			ch[left] = ch[right];
			ch[right] = temp;
			left++;
			right--;
		}
		return new String(ch);
	}`
      },

  {
        name: "Move Zeros",
        code: `//Input: nums = [0,1,0,3,12] Output: [1,3,12,0,0]
	public static void moveZeroes(int[] nums) {
		int j = 0;
		for (int i = 0; i < nums.length; i++) {
			if (nums[i] != 0) {
				int temp = nums[j];
				nums[j] = nums[i];
				nums[i] = temp;
				j++;
			}
		}
	}`
  },

      //...generateDummyProblems("Two Pointer", 1)
    ];


    // Sliding window problems
    const slidingWindowCategory = categories.find(cat => cat.name === "Sliding Window");
    slidingWindowCategory.problems = [
      {
        name: "Maximum Average Subarray I",
        code: `//Input: nums = [1,12,-5,-6,50,3], k = 4 Output: 12.75 , (12 - 5 - 6 + 50) / 4 = 51 / 4 = 12.75	 
	 
	public double findMaxAverage(int[] nums, int k) {
		int windowSum = 0;
		for (int i = 0; i < k; i++) {
			windowSum = windowSum + nums[i];
		}
		int maxSum = windowSum;

		int startIndex = 0;
		int endIndex = k;

		while (endIndex < nums.length) {
			windowSum = windowSum - nums[startIndex];
			startIndex++;

			windowSum = windowSum + nums[endIndex];
			endIndex++;
			maxSum = Math.max(maxSum, windowSum);
		}
		return (double) maxSum / k;
	}`
      },

      {
        name: "Find All Anagrams in a String",
        code: `//Input: s = "cbaebabacd", p = "abc" Output: [0,6]
	
	public static List<Integer> findAnagrams(String s, String p) {

		int[] pArr = new int[26];
		int[] sArr = new int[26];
		List<Integer> result = new java.util.ArrayList<>();

		for (char c : p.toCharArray()) {
			pArr[c - 'a']++;
		}

		for (int i = 0; i < s.length(); i++) {

			sArr[s.charAt(i) - 'a']++;

			if (i >= p.length()) {
				sArr[s.charAt(i -p.length()) - 'a']--;
			}

			if (Arrays.equals(pArr, sArr)) {
				result.add(i - p.length() + 1);
			}
		}
		return result;
	}`
      },

      {
        name: "Maximum Subarray",
        code: `//nums = [-2,1,-3,4,-1,2,1,-5,4].The subarray [4,-1,2,1] has the largest sum 6
	
	public int maxSubArray(int[] nums) {
		int maxSum = nums[0];
		int currentSum = 0;

		for (int i = 0; i < nums.length; i++) {
			if (currentSum < 0) {
				currentSum = 0;
			}
			currentSum = currentSum + nums[i];
			maxSum = Math.max(currentSum, maxSum);
		}
		return maxSum;
	}`
      },

    ];


    //Longest-Reverse problems
    const longestReverseCategory = categories.find(cat => cat.name === "Longest-Reverse");
    longestReverseCategory.problems = [
      {
        name: "Reverse Prefix of Word",
        code: `//Input: word = "abcdefd", ch = "d"	Output: "dcbaefd"
	
	public static String reversePrefix(String word, char ch) {

		if (firstOccurance == -1) {
			return word;
		}

		int firstOccurance = word.indexOf(ch);
		Stack<Character> stack = new Stack<>();
		
		for (int i = 0; i <= firstOccurance; i++) {
			stack.push(word.charAt(i));
		}

		StringBuffer result = new StringBuffer();
		while (!stack.isEmpty()) {
			result.append(stack.pop());
		}

		for (int j = firstOccurance + 1; j < word.length(); j++) {
			result.append(word.charAt(j));
		}

		return result.toString();
	}`
      },

      {
        name: "53. Maximum Subarray",
        code: ``
      },
    ];

    // Memoization problems
    const memoizationCategory = categories.find(cat => cat.name === "Memoization");
    memoizationCategory.problems = [
      {
        name: "Climb Stairs",
        code: `public int climbStairs(int n) {
        if (n == 1)
		return 1;
        
        int[] dp = new int[n + 1];
        dp[1] = 1;
        dp[2] = 2;

        for (int i = 3; i <= n; i++) {
            dp[i] = dp[i - 1] + dp[i -2];
        }
        return dp[n]; 
    }`
      },

      {
        name: "Coin change",
        code: `public int coinChange(int[] coins, int amount) {
      // Check edge case
      if (amount < 1) return 0;

      // Create DP array
      int[] minCoinsDP = new int[amount + 1];

      for (int i = 1; i <= amount; i++) {

        minCoinsDP[i] = Integer.MAX_VALUE;

        // Try each coin
        for (int coin : coins) {
          if (coin <= i && minCoinsDP[i - coin] != Integer.MAX_VALUE)
            minCoinsDP[i] = Math.min(minCoinsDP[i], 1 + minCoinsDP[i - coin]);
        }
      }
      return minCoinsDP[amount] == Integer.MAX_VALUE ? -1 : minCoinsDP[amount];
      }`
      },

      {
        name: "Longest Palindromic Substring",
        code: `String longestPalindrome(String str) {

		if (str.length() <= 1)
			return str;

		String LPS = "";

		for (int i = 1; i < str.length(); i++) {

			// Consider odd length----------------------------------------
			int low = i;
			int high = i;
			while (str.charAt(low) == str.charAt(high)) {
				low--;
				high++;

				if (low == -1 || high == str.length())
					break;
			}

			String palindrome = str.substring(low + 1, high);
			if (palindrome.length() > LPS.length()) {
				LPS = palindrome;
			}

			// Consider even length---------------------------------------
			low = i - 1;
			high = i;
			while (str.charAt(low) == str.charAt(high)) {
				low--;
				high++;

				if (low == -1 || high == str.length())
					break;
			}

			palindrome = str.substring(low + 1, high);
			if (palindrome.length() > LPS.length()) {
				LPS = palindrome;
			}
		}
		return LPS;
	}`
      },
    ];

    // Two Pointer problems
const hashMapCategory = categories.find(cat => cat.name === "HashMap DS");
hashMapCategory.problems = [
  {
    name: "Is Isomorphic",
    code: `//Input: s = "egg", t = "add" Output: true
class Solution {
    public boolean isIsomorphic(String s, String t) {
         if (s.length() != t.length()) {
          return false;
         }

    // Create a hashmap to store character mappings
    Map<Character, Character> charMappingMap = new HashMap<>();

    for (int i = 0; i < s.length(); i++) {
      char original = s.charAt(i);
      char replacement = t.charAt(i);

      if (!charMappingMap.containsKey(original)) {
        if (!charMappingMap.containsValue(replacement))
          charMappingMap.put(original, replacement);
        else
          return false;
      }
      else {
        char mappedCharacter = charMappingMap.get(original);
        if (mappedCharacter != replacement)
          return false;
      }
    }
    return true;		
    }
}`
  },
];


// Two Pointer problems
const brainTeasersCategory = categories.find(cat => cat.name === "Brain Teasers");
brainTeasersCategory.problems = [
  {
    name: "Left and Right Sum Differences",
    code: `//Input: nums = [10,4,8,3] Output: [15,1,11,22] || leftSum is [0,10,14,22],rightSum is [15,11,3,0]
class Solution {
public int[] leftRightDifference(int[] nums) {       

int rightSum = 0;
int leftSum = 0;

for (int i : nums) {
rightSum += i;//25
}

for (int i = 0; i < nums.length; i++) {
	int val = nums[i];
	rightSum = rightSum - val;//(25-10)=15|(15-4) = 11 |(11-8) = 3|(3-3)=0
	nums[i] = Math.abs(leftSum - rightSum);  //(0 -15)=15 |(10-11)=1 |(14-3)=11|(22-0)=22
	leftSum = leftSum + val; //(0+10)=10|(10+4)=14|(14+8)=22
	}
	return nums;	
  }
}`
  },
];



    // Fill others with dummy problems
    categories.forEach(cat => {
      if (!cat.problems.length) {
        cat.problems = generateDummyProblems(cat.name, 0);
      }
    });

    const tbody = document.getElementById("problem-table");

    categories.forEach((category, index) => {
      // Category row
      const catRow = document.createElement("tr");
      catRow.classList.add("category-row");
      catRow.innerHTML = `<td colspan="2">${category.name} <span class="toggle-icon" id="toggle-${index}">➕</span></td>`;
      tbody.appendChild(catRow);

      // Problem rows
      const problemRows = [];

      category.problems.forEach(problem => {
        const row = document.createElement("tr");
        row.classList.add(`category-${index}`, "hidden");
        row.innerHTML = `
          <td>${problem.name}</td>
          <td><button class="code-btn">Code</button></td>
        `;
        tbody.appendChild(row);
        problemRows.push(row);

        row.querySelector('button').addEventListener('click', () => showCode(problem.code));
      });

      // Toggle handler
      catRow.addEventListener('click', () => {
        const icon = document.getElementById(`toggle-${index}`);
        const isHidden = problemRows[0].classList.contains('hidden');
        problemRows.forEach(row => row.classList.toggle('hidden'));
        icon.textContent = isHidden ? '➖' : '➕';
      });
    });

    function showCode(code) {
      document.getElementById("codeText").textContent = code || "// Code not added yet";
      document.getElementById("codeModal").style.display = "flex";
    }

    function closeModal() {
      document.getElementById("codeModal").style.display = "none";
    }
  </script>

</body>

</html>